/* DSblock model generated by Dymola from Modelica model SimpleSpringDamperTask
 Dymola Version 2013 FD01 (32-bit), 2012-10-18 translated this at Sun Feb 16 11:34:09 2014

   */

#include <matrixop.h>
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
DYMOLA_STATIC const char*modelName="SimpleSpringDamperTask";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/diego/appdata/roaming/dynasim/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[4] = 4;
W_[5] = 0.0001;
W_[7] = false;
W_[9] = 3;
W_[13] = false;
W_[14] = 0;
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[3] = 0;
W_[10] = 0;
F_[1] = 0;
#endif
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection
Init=false;InitializeData(2);Init=true;
EndInitialSection

OutputSection

DynamicsSection
F_[0] = X_[1];
W_[6] = DP_[3]*X_[1];
W_[2] = X_[0]+DP_[0];
W_[3] = W_[2]-DP_[0];
W_[1] =  -DP_[1]*(W_[3]-DP_[2]);
W_[11] = W_[1]-W_[6];
 /* Linear system of equations to solve. */
F_[1] = RememberSimple_(F_[1], 0);
SolveScalarLinearParametric(DP_[4],"mass.m", W_[11]+DP_[6],"mass.flange_a.f+const.k",
   F_[1],"der(damper.v_rel)");
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
W_[10] = W_[2]+DP_[5]/(double)(2);
W_[0] = W_[6]-W_[1];
W_[8] = W_[6]*X_[1];
W_[12] = W_[10]+DP_[5]/(double)(2);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("fixed.s0", "Fixed offset position of housing [m]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("fixed.flange.s", "Absolute position of flange [m]", "fixed.s0", 1,\
 7, 0, 4)
DeclareVariable("fixed.flange.f", "Cut force directed into flange [N]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("spring.flange_a.s", "Absolute position of flange [m]", "fixed.s0", 1,\
 7, 0, 4)
DeclareVariable("spring.flange_a.f", "Cut force directed into flange [N]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("spring.flange_b.s", "Absolute position of flange [m]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("spring.flange_b.f", "Cut force directed into flange [N]", \
"spring.flange_a.f", -1, 5, 1, 132)
DeclareVariable("spring.s_rel", "Relative distance (= flange_b.s - flange_a.s) [m]",\
 0, 0.0,1E+100,0.0,0,512)
DeclareAlias2("spring.f", "Force between flanges (positive in direction of flange axis R) [N]",\
 "spring.flange_a.f", -1, 5, 1, 0)
DeclareParameter("spring.c", "Spring constant  [N/m]", 1, 10, 0.0,1E+100,0.0,0,560)
DeclareParameter("spring.s_rel0", "Unstretched spring length [m]", 2, 0, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("damper.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("damper.s_nominal", "Nominal value of s_rel (used for scaling) [m]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareState("damper.s_rel", "Relative distance (= flange_b.s - flange_a.s) [m]",\
 0, 0, 0.0,1E+100,0.0001,0,560)
DeclareDerivative("damper.der(s_rel)", "der(Relative distance (= flange_b.s - flange_a.s)) [m/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("damper.v_rel", "Relative velocity (= der(s_rel)) [m/s]", 1, 0, \
0.0,0.0,0.0,0,560)
DeclareDerivative("damper.der(v_rel)", "der(Relative velocity (= der(s_rel))) [m/s2]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("damper.f", "Forces between flanges (= flange_b.f) [N]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("damper.flange_a.s", "Absolute position of flange [m]", "fixed.s0", 1,\
 7, 0, 4)
DeclareAlias2("damper.flange_a.f", "Cut force directed into flange [N]", \
"damper.f", -1, 5, 6, 132)
DeclareAlias2("damper.flange_b.s", "Absolute position of flange [m]", \
"spring.flange_b.s", 1, 5, 2, 4)
DeclareAlias2("damper.flange_b.f", "Cut force directed into flange [N]", \
"damper.f", 1, 5, 6, 132)
DeclareParameter("damper.d", "Damping constant [N.s/m]", 3, 2, 0.0,1E+100,0.0,0,560)
DeclareVariable("damper.useHeatPort", "=true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("damper.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("mass.m", "Mass of the sliding mass [kg]", 4, 1, 0.0,1E+100,0.0,\
0,560)
DeclareVariable("mass.stateSelect", "Priority to use s and v as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,517)
DeclareVariable("mass.s", "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2) [m]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass.der(s)", "der(Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)) [m/s]",\
 "damper.v_rel", 1, 1, 1, 0)
DeclareParameter("mass.L", "Length of component, from left flange to right flange (= flange_b.s - flange_a.s) [m]",\
 5, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("mass.flange_a.s", "Absolute position of flange [m]", \
"spring.flange_b.s", 1, 5, 2, 4)
DeclareVariable("mass.flange_a.f", "Cut force directed into flange [N]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("mass.flange_b.s", "Absolute position of flange [m]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("mass.flange_b.f", "Cut force directed into flange [N]", "const.k", 1,\
 7, 6, 132)
DeclareAlias2("mass.v", "Absolute velocity of component [m/s]", "damper.v_rel", 1,\
 1, 1, 0)
DeclareAlias2("mass.der(v)", "der(Absolute velocity of component) [m/s2]", \
"damper.der(v_rel)", 1, 6, 1, 0)
DeclareAlias2("mass.a", "Absolute acceleration of component [m/s2]", \
"damper.der(v_rel)", 1, 6, 1, 0)
DeclareVariable("force.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("force.s", "Distance between flange and support (= flange.s - support.s) [m]",\
 "mass.flange_b.s", 1, 5, 12, 0)
DeclareAlias2("force.flange.s", "Absolute position of flange [m]", \
"mass.flange_b.s", 1, 5, 12, 4)
DeclareAlias2("force.flange.f", "Cut force directed into flange [N]", "const.k", -1,\
 7, 6, 132)
DeclareVariable("force.s_support", "Absolute position of support flange [m]", 0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("force.f", "Driving force as input signal [N]", "const.k", 1, 7, 6,\
 0)
DeclareParameter("const.k", "Constant output value", 6, -10, 0.0,0.0,0.0,0,560)
DeclareAlias2("const.y", "Connector of Real output signal [N]", "const.k", 1, 7,\
 6, 0)
EndNonAlias(0)
#define NX_    2
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    15
#define NP_    7
#define NPS_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -492931557
#define NHash2_ -1254579846
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    19
#define SizePre_ 0
#define SizeEq_ 1
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[1];
}
StartDataBlock
StartEqBlock
DoRemember_(F_[1], 0, 0);
EndEqBlock
EndDataBlock
